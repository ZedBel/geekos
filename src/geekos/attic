
      
#ifdef OLD
    /* need a new block; find the end; let's hope we don't recurse too much. */
    if (block_index > 0) {
      gfs3_blocknum last = find_or_allocate_block_num_in_inode(instance, 
                                                               inode, inum, block_index-1, &e);
      char *in_use_bits;
      if(last == 0) {
        Print("Unable to allocate predecessor block %d\n", block_index-1);
        KASSERT(0);
        return 0;
      }
      KASSERT(last < instance->number_of_blocks);
        in_use_bits = get_bitmap_of_free_blocks(instance);
      KASSERT(in_use_bits);
      if( Is_Bit_Set(in_use_bits, last+1) ) { 
        /* need new extent */
        Print("need new extent because last %d + 1 is in use, extent[%d] = %d+%d\n", 
              last, e, inode->extents[e].start_block, inode->extents[e].length_blocks);
        for(e=0; e<GFS3_EXTENTS && inode->extents[e].length_blocks; e++);
        if(e >= GFS3_EXTENTS) { /* coalesce existing bits and recurse. */
          unsigned int consecutive_blocks_desired  = MAX(block_index + 1, (inode->size + SECTOR_SIZE-1) / SECTOR_SIZE);
          int start = Find_First_N_Free(in_use_bits, consecutive_blocks_desired, instance->number_of_blocks);
          unsigned int i;
          struct gfs3_inode *writable_inode;
          if (start < 0) {
            Print("couldn't rearrange extents in inode %d to be a single of length %d blocks for size %u, requested block %u; try a filesystem larger than %u blocks.\n",
                  inum, consecutive_blocks_desired, inode->size, block_index, instance->number_of_blocks);
            for(i = 0; i<instance->number_of_blocks / 8; i++) {
              Print("%x", in_use_bits[i]);
            }
            Print("\n");
            Print("while asking for %d consecutive blocks\n", consecutive_blocks_desired);
            Free(in_use_bits);
            return 0;
          }
          for(i=0; i<consecutive_blocks_desired; i++) {
            unsigned int unused;
            struct FS_Buffer *rdbuf, *wrbuf;
            gfs3_blocknum orig = find_or_allocate_block_num_in_inode(instance, 
                                                                     inode, inum, i, &unused);
            KASSERT(orig < instance->number_of_blocks);
            Print("gfs3 rearranging inum %d block %d (extent %d) -> newblock %d\n", inum, orig, unused, start+i);
            if(Get_FS_Buffer(instance->cache, orig, &rdbuf)==0) {
              Clear_Bit(in_use_bits, orig); release_disk_block(instance, orig);
              if(Get_FS_Buffer(instance->cache, start+i, &wrbuf)==0) {
                memcpy(wrbuf->data, rdbuf->data, SECTOR_SIZE);
                Modify_FS_Buffer(instance->cache, wrbuf);
                Release_FS_Buffer(instance->cache, rdbuf);
                Release_FS_Buffer(instance->cache, wrbuf);
              }
              Set_Bit(in_use_bits, start+i); claim_disk_block(instance, start+i);
            }
          }
          writable_inode = get_me_a_specific_inode_writable(instance, inum, &buffy);
          writable_inode->extents[0].start_block = start;
          writable_inode->extents[0].length_blocks = consecutive_blocks_desired;
          for(i=1; i<GFS3_EXTENTS;i++) {
            writable_inode->extents[i].start_block = 0;
            writable_inode->extents[i].length_blocks = 0;
          }
          memcpy(inode, writable_inode, sizeof(struct gfs3_inode));
          Modify_FS_Buffer(instance->cache, buffy); 
          Release_FS_Buffer(instance->cache, buffy); 
          Free(in_use_bits);
          return find_or_allocate_block_num_in_inode(instance, inode, inum, block_index, extent);
        } else {
          gfs3_blocknum new_block = claim_next_free_block(instance); 
          struct gfs3_inode *writable_inode = get_me_a_specific_inode_writable(instance, inum, &buffy);
          writable_inode->extents[e].start_block =  new_block;
          writable_inode->extents[e].length_blocks = 1;
          Modify_FS_Buffer(instance->cache, buffy); 
          Release_FS_Buffer(instance->cache, buffy); 
          *extent = e;
          Free(in_use_bits);
          return new_block;
        }
      } else {
        struct gfs3_inode *writable_inode;
        /* extend teh extent */
        KASSERT(e<GFS3_EXTENTS);
        // Print("extending\n");
        Set_Bit(in_use_bits, last + 1); claim_disk_block(instance, last + 1);
        writable_inode = get_me_a_specific_inode_writable(instance, inum, &buffy);
        KASSERT( writable_inode->extents[e].start_block + writable_inode->extents[e].length_blocks == last + 1);
        writable_inode->extents[e].length_blocks += 1;
        Modify_FS_Buffer(instance->cache, buffy); 
        Release_FS_Buffer(instance->cache, buffy); 
        *extent = e;
        Free(in_use_bits);
        return last + 1;
      }
    } else {
      gfs3_blocknum new_block = claim_next_free_block(instance); 
      struct gfs3_inode *writable_inode = get_me_a_specific_inode_writable(instance, inum, &buffy);
      KASSERT(writable_inode != NULL);
      writable_inode->extents[0].start_block = new_block;
      writable_inode->extents[0].length_blocks = 1;
      Modify_FS_Buffer(instance->cache, buffy); 
      Release_FS_Buffer(instance->cache, buffy); 
      *extent = 0;
      return new_block;
    }
    Print("should be unreachable\n");
  } 
#endif

